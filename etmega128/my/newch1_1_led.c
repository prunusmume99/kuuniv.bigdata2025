#include <avr/interrupt.h>
#include <avr/io.h>

// 전역 변수 선언
// ledData: LED에 출력할 데이터. 0x00부터 시작하며, 0x0F까지 값을 순환합니다.
volatile uint8_t ledData = 0x00;

// timer0Cnt: Timer0의 오버플로우 발생 횟수를 카운트하는 변수입니다.
uint8_t timer0Cnt = 0;

// Timer0 오버플로우 인터럽트 서비스 루틴(ISR) 선언
ISR(TIMER0_OVF_vect);

int main(void)
{
    // DDRC = 0x0F;  
    // 포트 C의 하위 4비트(PC0~PC3)를 출력으로 설정합니다.
    // 나머지 상위 비트는 입력으로 설정됩니다.
    DDRC = 0x0F;

    // TCCR0 = 0x07;
    // 타이머/카운터0 제어 레지스터 설정:
    // 내부 클록을 사용하고, 분주비(prescaler)를 1024로 설정합니다.
    // 0x07는 CS02, CS01, CS00 비트 모두 1로 설정된 값입니다.
    TCCR0 = 0x07;

    // TCNT0 = 112;
    // 타이머/카운터0의 초기 카운트 값을 112로 설정합니다.
    // (112 ~ 255까지 카운트하면 총 144 카운트 후 오버플로우가 발생합니다.)
    TCNT0 = 112;

    // TIMSK = 0x01;
    // 타이머/카운터 인터럽트 마스크 레지스터 설정:
    // TIMSK의 비트 0(TIMER0 오버플로우 인터럽트)을 활성화합니다.
    TIMSK = 0x01;

    // TIFR |= _BV(TOV0);
    // 타이머 인터럽트 플래그 레지스터(TIFR)의 TOV0 비트를 1로 설정하여
    // 기존의 오버플로우 플래그를 클리어(초기화)합니다.
    TIFR |= _BV(TOV0);

    // sei();
    // 전역 인터럽트를 활성화합니다.
    sei();

    // 메인 루프: 무한 반복하며 LED에 출력할 값을 업데이트합니다.
    while (1)
    {
        // timer0Cnt가 100이 되면, (약 100 * 2.5ms = 250ms 주기라 가정)
        // LED에 출력할 데이터를 1씩 증가시킵니다.
        if (timer0Cnt == 100)
        {
            ledData++;              // ledData 값을 증가시킴
            if (ledData > 0x0F)     // ledData가 0x0F(15)보다 크면
                ledData = 0;        // 0으로 초기화하여 순환하도록 합니다.
            timer0Cnt = 0;          // 타이머 카운트 변수 리셋
        }
        // PORTC에 ledData 값을 출력합니다.
        // DDRC가 0x0F로 설정되었으므로, 하위 4비트에만 LED 연결이 있다고 가정합니다.
        PORTC = ledData;
    }
}

// Timer0 오버플로우 인터럽트 서비스 루틴
// 타이머/카운터0가 255에서 오버플로우 될 때마다 실행됩니다.
ISR(TIMER0_OVF_vect)
{
    cli(); // 인터럽트 중첩 실행 방지를 위해 인터럽트를 잠시 비활성화합니다.

    // TCNT0를 다시 112로 설정합니다.
    // 이로써 타이머는 112부터 다시 카운트를 시작하며,
    // 112부터 255까지 144 카운트 후 다시 오버플로우가 발생합니다.
    // 예를 들어, 내부 클록이 1MHz이고 분주비가 1024일 경우,
    // 한 카운트 당 시간은 약 1024µs이며, 144 카운트는 약 147456µs(약 0.147초)가 됩니다.
    // (주석에 언급된 0.0025초는 클록 속도나 분주비에 따라 달라질 수 있습니다.)
    TCNT0 = 112;

    // 타이머 오버플로우 횟수를 1 증가시킵니다.
    timer0Cnt++;

    sei(); // 인터럽트를 다시 활성화합니다.
}
